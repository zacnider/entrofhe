# HandleLifecycle

Understanding handles and symbolic execution

## Overview

@title HandleLifecycle
@notice Understanding handles and symbolic execution
@dev Educational example explaining handles and their lifecycle
@chapter handles
This example explains:
- What are handles?
- How handles are generated
- Symbolic execution in FHEVM
- Handle lifecycle and permissions
Handles:
- Handles are references to encrypted values
- Generated by FHEVM SDK when encrypting values
- Used to reference encrypted data in contracts
- Handles are not the actual encrypted data, just references
Symbolic Execution:
- FHEVM uses symbolic execution to track encrypted values
- Handles represent encrypted values symbolically
- Operations on handles are tracked symbolically
- Actual decryption happens off-chain

@notice Store encrypted value (handle)
@param encryptedInput Encrypted input with handle
@param inputProof Input proof
@dev
Handle Lifecycle:
1. User encrypts value off-chain → generates handle
2. Handle sent to contract via externalEuint64
3. Contract converts to internal euint64 (still a handle)
4. Contract stores handle in state
5. Handle can be used in FHE operations
6. Handle can be returned for off-chain decryption

@notice Use handle in FHE operation
@dev Demonstrates using stored handle in FHE operations
@return Result of FHE operation (also a handle)

@notice Get stored handle
@return Handle to encrypted value
@dev Returns handle, not decrypted value
@dev User must decrypt off-chain using FHEVM SDK

@notice Check if initialized



## Contract Code

```solidity
// SPDX-License-Identifier: BSD-3-Clause-Clear
pragma solidity ^0.8.27;

import {FHE, euint64, externalEuint64} from "@fhevm/solidity/lib/FHE.sol";
import {ZamaEthereumConfig} from "@fhevm/solidity/config/ZamaConfig.sol";

/**
 * @title HandleLifecycle
 * @notice Understanding handles and symbolic execution
 * @dev Educational example explaining handles and their lifecycle
 * @chapter handles
 * 
 * This example explains:
 * - What are handles?
 * - How handles are generated
 * - Symbolic execution in FHEVM
 * - Handle lifecycle and permissions
 * 
 * Handles:
 * - Handles are references to encrypted values
 * - Generated by FHEVM SDK when encrypting values
 * - Used to reference encrypted data in contracts
 * - Handles are not the actual encrypted data, just references
 * 
 * Symbolic Execution:
 * - FHEVM uses symbolic execution to track encrypted values
 * - Handles represent encrypted values symbolically
 * - Operations on handles are tracked symbolically
 * - Actual decryption happens off-chain
 */
contract HandleLifecycle is ZamaEthereumConfig {
    euint64 private encryptedValue;
    bool private initialized;
    
    event HandleStored(address indexed user);
    event HandleUsed();
    
    /**
     * @notice Store encrypted value (handle)
     * @param encryptedInput Encrypted input with handle
     * @param inputProof Input proof
     * @dev 
     * Handle Lifecycle:
     * 1. User encrypts value off-chain → generates handle
     * 2. Handle sent to contract via externalEuint64
     * 3. Contract converts to internal euint64 (still a handle)
     * 4. Contract stores handle in state
     * 5. Handle can be used in FHE operations
     * 6. Handle can be returned for off-chain decryption
     */
    function storeHandle(
        externalEuint64 encryptedInput,
        bytes calldata inputProof
    ) external {
        require(!initialized, "Already initialized");
        
        // Step 1: Convert external handle to internal handle
        // The handle is a reference, not the actual encrypted data
        euint64 internalHandle = FHE.fromExternal(encryptedInput, inputProof);
        
        // Step 2: Grant contract permission to use this handle
        // This is required for FHE operations
        FHE.allowThis(internalHandle);
        
        // Step 3: Store handle in contract state
        // The handle is stored, not the actual encrypted value
        encryptedValue = internalHandle;
        initialized = true;
        
        emit HandleStored(msg.sender);
    }
    
    /**
     * @notice Use handle in FHE operation
     * @dev Demonstrates using stored handle in FHE operations
     * @return Result of FHE operation (also a handle)
     */
    function useHandle() external returns (euint64) {
        require(initialized, "Not initialized");
        
        // Use stored handle in FHE operation
        // The operation is performed symbolically
        euint64 one = FHE.asEuint64(1);
        euint64 result = FHE.add(encryptedValue, one);
        
        // Result is also a handle (not decrypted value)
        emit HandleUsed();
        
        return result;
    }
    
    /**
     * @notice Get stored handle
     * @return Handle to encrypted value
     * @dev Returns handle, not decrypted value
     * @dev User must decrypt off-chain using FHEVM SDK
     */
    function getHandle() external view returns (euint64) {
        require(initialized, "Not initialized");
        return encryptedValue;
    }
    
    /**
     * @notice Check if initialized
     */
    function isInitialized() external view returns (bool) {
        return initialized;
    }
}

```

## Tests

See [test file](../examples/handles-handlelifecycle/test/HandleLifecycle.test.ts) for comprehensive test coverage.

```bash
npm test
```


## Category

**handles**

## Chapter

`handles`

## Related Examples

- [All handles examples](../examples/handles/)
